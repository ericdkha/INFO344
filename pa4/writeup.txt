For PA4, the hardest part overcome was figuring out to connect all the past programming assignment together. However, guidance was provided on how to do this on the Canvas assignment, and that made it more clear on how to tackle the problem. I first started by implementing a php file in my PA1 that when called, it would return a JSONP object to my webservice. The JSONP file would contain information about a basketball player if one was found with the passed input, if not, it would return blank.
After I got PA1 API to return what I needed (nba player stats), I started modifying my PA2. I kept the majority of the code the same, except I moved everything from my PA3 over into my PA2. I also added code to use the PA1 API that I made so that I can asynchronously make searches to the API and get back player stats if found. I used the code from PA3 to search for crawled urls and modified it so that it would search for keywords instead. This part was probably the most confusing when trying to connect the dots. I had to modify several of my PA3 code such as my UrlInfo class and the way my worker role inserted urls into the table (using words as the partition key). The JQuery aspect of this assignment was probably the easiest because I’m the most familiar with client-side programming. My javascript calls several different functions on each keystroke: the Query Suggestion, PA1 API, and Search Titles. The last thing I implemented was the LINQ statement to rank my results based on match keywords, to do this I spent some time on google to see how I can use LINQ in different ways. After testing and trying out several LINQ statements, I was able to use one that worked on sorting results by matched keyword counts.

For the End-to-End experience, specifically the dashboard, caching, and monetization part, I was able to easily do these. I used my dashboard from PA3 and added the new relevant stats (# of entries in trie and last insertion) and I created a button so that users can switch between the main search page and the dashboard. Caching was sort of difficult, but the example form class proved to be helpful, because I was able to refer back to it and kind of get the gist of how to implement it for my own code. Although I ran into some issues trying to fit the cache in to the whole network of things, I could implement it successfully. The way I implemented it was using a dictionary of strings and a list of my UrlInfo object. I also added a “Clear Cache” button on the search page, so that when users want updated titles, they could clear the cache and re-query their search. The Crawler is running in the background so new titles are constantly being added. For the monetization, I applied for Adsense by Google but was then rejected. I tried other services, but I didn’t like the way the ads appeared on my page. I saw on the discussion board about a service called Chitika, and was able to add a snippet of their code into my html, and I was able to get the ad up and running on my page.
